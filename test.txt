

    def speak_text_streaming(self, text_queue, stop_event):
        """Stream TTS audio from a queue of text chunks with parallel generation and playback"""
        import subprocess
        import threading
        import queue
        import os
        import tempfile
        
        audio_queue = queue.Queue(maxsize=5)  # Buffer up to 5 audio files
        audio_counter = [0]  # Use list to allow modification in nested function
        
        def tts_generator():
            """Generate audio files from text queue"""
            while not stop_event.is_set() or not text_queue.empty():
                try:
                    text_chunk = text_queue.get(timeout=0.3)
                    if text_chunk and len(text_chunk.strip()) > 0:
                        # Generate unique temp file for this chunk
                        audio_counter[0] += 1
                        temp_audio = f"/tmp/chatty_audio_{audio_counter[0]}.wav"
                        
                        command = [
                            PIPER_EXECUTABLE,
                            "--model", VOICE_PATH,
                            "--config", CONFIG_PATH,
                            "--output_file", temp_audio
                        ]
                        subprocess.run(command, input=text_chunk.encode("utf-8"), check=True, capture_output=True)
                        audio_queue.put(temp_audio)
                    text_queue.task_done()
                except queue.Empty:
                    pass
                except Exception as e:
                    print(f"[TTS Generator] Error: {e}")
            # Signal end of audio
            audio_queue.put(None)
        
        def audio_player():
            """Play audio files from queue"""
            while True:
                try:
                    audio_file = audio_queue.get(timeout=1.0)
                    if audio_file is None:
                        break
                    if os.path.exists(audio_file):
                        with self.audio_recording_lock:
                            subprocess.run(["aplay", audio_file], check=True, capture_output=True)
                        # Clean up temp file
                        try:
                            os.remove(audio_file)
                        except:
                            pass
                    audio_queue.task_done()
                except queue.Empty:
                    if stop_event.is_set() and text_queue.empty():
                        break
                except Exception as e:
                    print(f"[Audio Player] Error: {e}")
        
        # Start both threads
        generator_thread = threading.Thread(target=tts_generator, daemon=True)
        player_thread = threading.Thread(target=audio_player, daemon=True)
        
        generator_thread.start()
        player_thread.start()
        
        # Wait for both to complete
        generator_thread.join(timeout=120)
        player_thread.join(timeout=120)


