


Let's optimize all three issues. First, let me check the current audio buffer settings and understand the flow better:
bashgrep -n "InputStream\|buffer\|blocksize\|latency" /home/nickspi5/Chatty_AI/chatty_ai.py | head -20
Also, let's see the current chunk duration and command detection logic:
bashsed -n '820,920p' /home/nickspi5/Chatty_AI/chatty_ai.py

Now let's create an optimized version of the record_with_streaming_transcription function that:

Fixes input overflow - Uses proper buffer size and blocksize parameters
Speeds up partial transcription - Reduces chunk duration from 2s to 1s
Optimizes early command detection - Executes commands immediately when detected

bashnano /home/nickspi5/Chatty_AI/chatty_ai.py
Replace the entire record_with_streaming_transcription function with this optimized version:
python    def record_with_streaming_transcription(self):
        """Record audio with real-time transcription in chunks - OPTIMIZED"""
        try:
            # Auto-detect working sample rate
            working_sample_rate = None
            for rate in [16000, 22050, 44100, 48000]:  # Prefer lower rates first
                try:
                    sd.check_input_settings(channels=1, samplerate=rate, dtype='float32')
                    working_sample_rate = rate
                    break
                except:
                    continue
            
            if not working_sample_rate:
                self.emit_log("No compatible sample rate found", 'error')
                return None
            
            with self.audio_recording_lock:
                self.emit_log(f"Streaming recording at {working_sample_rate} Hz", 'debug')
                
                full_transcript = ""
                silence_duration = 0
                recording_duration = 0
                chunk_duration = 1.0  # Transcribe every 1 second (faster feedback)
                last_transcription_time = 0
                check_interval = 0.05  # Check more frequently (50ms)
                samples_per_check = int(working_sample_rate * check_interval)
                
                # Use a thread-safe list for audio buffer
                audio_buffer = []
                buffer_lock = threading.Lock()
                
                # Calculate optimal blocksize to prevent overflow
                blocksize = int(working_sample_rate * 0.1)  # 100ms blocks
                
                def audio_callback(indata, frames, time_info, status):
                    if status:
                        # Only log if it's not an overflow (reduce noise)
                        if 'overflow' not in str(status).lower():
                            self.emit_log(f"Audio status: {status}", 'warning')
                    with buffer_lock:
                        audio_buffer.extend(indata[:, 0].copy())
                
                # Use explicit blocksize and latency settings
                with sd.InputStream(callback=audio_callback, 
                                  samplerate=working_sample_rate, 
                                  channels=1,
                                  dtype='float32',
                                  blocksize=blocksize,
                                  latency='low'):
                    
                    command_detected = None
                    
                    while recording_duration < 30:  # Max 30 seconds
                        time.sleep(check_interval)
                        recording_duration += check_interval
                        
                        with buffer_lock:
                            buffer_len = len(audio_buffer)
                        
                        if buffer_len >= samples_per_check:
                            with buffer_lock:
                                recent_audio = np.array(audio_buffer[-samples_per_check:])
                            rms = np.sqrt(np.mean(recent_audio**2))
                            
                            if recording_duration >= 0.5:  # Start checking after 0.5s
                                if rms < SILENCE_THRESHOLD:
                                    silence_duration += check_interval
                                else:
                                    if silence_duration > 0.5:
                                        self.emit_log(f"Speech resumed after {silence_duration:.1f}s silence", 'debug')
                                    silence_duration = 0
                                
                                # Log progress every second
                                if int(recording_duration) > int(recording_duration - check_interval):
                                    self.emit_log(f"Recording: {recording_duration:.1f}s | RMS: {rms:.4f} | Silence: {silence_duration:.1f}s", 'debug')
                                
                                # Transcribe chunk every chunk_duration seconds
                                if recording_duration - last_transcription_time >= chunk_duration and buffer_len > 0:
                                    # Save current audio to temp file
                                    with buffer_lock:
                                        temp_audio = np.array(audio_buffer)
                                    temp_file = "/tmp/streaming_chunk.wav"
                                    
                                    # Resample if needed
                                    if working_sample_rate != 16000:
                                        from scipy import signal
                                        num_samples = int(len(temp_audio) * 16000 / working_sample_rate)
                                        if num_samples > 0:
                                            temp_audio = signal.resample(temp_audio, num_samples)
                                    
                                    # Normalize
                                    max_val = np.max(np.abs(temp_audio))
                                    if max_val > 0:
                                        temp_audio = temp_audio / max_val * 0.9
                                    
                                    # Save as WAV
                                    import wave
                                    with wave.open(temp_file, 'w') as wf:
                                        wf.setnchannels(1)
                                        wf.setsampwidth(2)
                                        wf.setframerate(16000)
                                        wf.writeframes((temp_audio * 32767).astype(np.int16).tobytes())
                                    
                                    # Transcribe chunk
                                    chunk_transcript = self.transcribe_audio(temp_file)
                                    if chunk_transcript and chunk_transcript.strip():
                                        full_transcript = chunk_transcript
                                        self.emit_log(f"[STREAMING STT] Partial: '{full_transcript}'", 'info')
                                        socketio.emit('partial_transcript', {'text': full_transcript})
                                        
                                        # Check for command in partial transcript - EARLY DETECTION
                                        command = self.is_command(full_transcript)
                                        if command:
                                            self.emit_log(f"[STREAMING STT] Command detected early: {command}", 'success')
                                            command_detected = command
                                            # Don't break yet - save audio first
                                            break
                                    
                                    last_transcription_time = recording_duration
                                
                                # Stop on silence (only after we have some audio)
                                if silence_duration >= MIN_SILENCE_DURATION and recording_duration > 1.5:
                                    self.emit_log(f"Silence detected! Recorded {recording_duration:.1f}s", 'debug')
                                    break
                
                # Save final audio
                with buffer_lock:
                    if len(audio_buffer) > 0:
                        full_audio = np.array(audio_buffer)
                    else:
                        return False
                
                # Resample to 16kHz for Whisper
                if working_sample_rate != 16000:
                    from scipy import signal
                    num_samples = int(len(full_audio) * 16000 / working_sample_rate)
                    if num_samples > 0:
                        full_audio = signal.resample(full_audio, num_samples)
                
                # Normalize
                max_val = np.max(np.abs(full_audio))
                if max_val > 0:
                    full_audio = full_audio / max_val * 0.9
                
                # Save final audio
                import wave
                with wave.open(WAV_FILENAME, 'w') as wf:
                    wf.setnchannels(1)
                    wf.setsampwidth(2)
                    wf.setframerate(16000)
                    wf.writeframes((full_audio * 32767).astype(np.int16).tobytes())
                
                self.emit_log(f"Audio saved: {len(full_audio)/16000:.1f}s", 'debug')
                return True
                
        except Exception as e:
            self.emit_log(f"Streaming recording error: {e}", 'error')
            import traceback
            traceback.print_exc()
            return False
Save and exit.

Test for Syntax Errors
bashcd /home/nickspi5/Chatty_AI
source chatty-venv/bin/activate
python3 -m py_compile chatty_ai.py && echo "No syntax errors!"

Restart and Test
bashsudo systemctl restart chatty-ai.service
Test with:

A question like "Tell me about the moon"
A command like "flush the toilet" - it should detect early

bashjournalctl -u chatty-ai.service -f




