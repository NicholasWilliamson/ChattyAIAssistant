

Perfect! The wake word detection is working correctly now. The issue is just with the user input recording after the wake word is detected - it's still using an unsupported sample rate.
Looking at your logs, the error occurs in the user input recording phase:

Wake word detection: ✅ Working
User input recording: ❌ Sample rate error

Let's fix just the user input recording function. First, let's check what sample rates your system supports:

bashcd /home/nickspi5/Chatty_AI
python3 -c "
import sounddevice as sd
print('Testing sample rates for your system:')
for rate in [44100, 48000, 22050, 16000, 11025, 8000]:
    try:
        sd.check_input_settings(channels=1, samplerate=rate, dtype='float32')
        print(f'{rate} Hz: SUPPORTED ✓')
    except Exception as e:
        print(f'{rate} Hz: NOT SUPPORTED - {e}')
"

Once we know what rates work, we need to update just the record_with_silence_detection method in your chatty_ai.py. The error is happening because this method is trying to use SAMPLE_RATE = 16000 which your audio system doesn't support.

Here's the targeted fix - find the record_with_silence_detection method in your chatty_ai.py and replace it with this version that auto-detects the sample rate:

def record_with_silence_detection(self):
    """Record audio until silence is detected with compatible sample rate"""
    
    # Auto-detect working sample rate
    working_sample_rate = None
    for rate in [44100, 48000, 22050, 16000]:
        try:
            sd.check_input_settings(channels=1, samplerate=rate, dtype='float32')
            working_sample_rate = rate
            break
        except:
            continue
    
    if not working_sample_rate:
        self.emit_log("No compatible sample rate found", 'error')
        return False
    
    self.emit_log(f"Recording with sample rate: {working_sample_rate} Hz", 'debug')
    
    audio_data = []
    silence_duration = 0
    recording_duration = 0
    check_interval = 0.1
    samples_per_check = int(working_sample_rate * check_interval)
    
    def audio_callback(indata, frames, time, status):
        if status:
            self.emit_log(f"Audio status: {status}", 'warning')
        audio_data.extend(indata[:, 0])
    
    try:
        with sd.InputStream(callback=audio_callback, 
                          samplerate=working_sample_rate, 
                          channels=1,
                          dtype='float32'):
            
            while recording_duration < 30:  # Max 30 seconds
                time.sleep(check_interval)
                recording_duration += check_interval
                
                if len(audio_data) >= samples_per_check:
                    recent_audio = np.array(audio_data[-samples_per_check:])
                    rms = np.sqrt(np.mean(recent_audio**2))
                    
                    # Debug every second
                    if int(recording_duration * 10) % 10 == 0:
                        self.emit_log(f"Recording: {recording_duration:.1f}s | Audio: {rms:.4f} | Silence: {silence_duration:.1f}s", 'debug')
                    
                    if rms < SILENCE_THRESHOLD:
                        silence_duration += check_interval
                        if silence_duration >= MIN_SILENCE_DURATION:
                            self.emit_log(f"Silence detected! Recorded {recording_duration:.1f}s", 'info')
                            break
                    else:
                        silence_duration = 0
        
        # Save audio (convert to 16kHz for Whisper if needed)
        if len(audio_data) > 0:
            audio_array = np.array(audio_data)
            
            # Convert to 16kHz for Whisper if we recorded at different rate
            if working_sample_rate != 16000:
                from scipy import signal
                target_length = int(len(audio_array) * 16000 / working_sample_rate)
                audio_array = signal.resample(audio_array, target_length)
                save_sample_rate = 16000
            else:
                save_sample_rate = working_sample_rate
                
            sf.write(USER_AUDIO_FILE, audio_array, save_sample_rate)
            self.emit_log(f"Audio saved: {len(audio_array)/save_sample_rate:.1f}s", 'info')
            return True
        else:
            return False
            
    except Exception as e:
        self.emit_log(f"Recording error: {e}", 'error')
        return False



